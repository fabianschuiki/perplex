// Code automatically generated by perplex.

/// All nonterminals that may be pushed onto the stack.
enum Nonterminal {
    Nt0(()),
    Nt1(()),
    Nt2(()),
    Nt3(()),
    Nt4(()),
}

impl Nonterminal {
    #[inline(always)]
    fn unwrap_nt0(self) -> () {
        match self {
            Nonterminal::Nt0(nt) => nt,
            _ => panic!("expected nonterminal `()`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt1(self) -> () {
        match self {
            Nonterminal::Nt1(nt) => nt,
            _ => panic!("expected nonterminal `()`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt2(self) -> () {
        match self {
            Nonterminal::Nt2(nt) => nt,
            _ => panic!("expected nonterminal `()`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt3(self) -> () {
        match self {
            Nonterminal::Nt3(nt) => nt,
            _ => panic!("expected nonterminal `()`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt4(self) -> () {
        match self {
            Nonterminal::Nt4(nt) => nt,
            _ => panic!("expected nonterminal `()`"),
        }
    }
}

impl std::fmt::Debug for Nonterminal {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match *self {
            Nonterminal::Nt0(..) => write!(f, "desc"),
            Nonterminal::Nt1(..) => write!(f, "item"),
            Nonterminal::Nt2(..) => write!(f, "token_decl"),
            Nonterminal::Nt3(..) => write!(f, "rule_decl"),
            Nonterminal::Nt4(..) => write!(f, "rule_list"),
        }
    }
}

fn state_0<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Ident(_)) => p.shift(state_7, reduced_7),
        Some(Token::Keyword(Keyword::Token)) => p.shift(state_6, reduced_6),
        Some(Token::Semicolon) => p.shift(state_3, reduced_3),
        _ => panic!("syntax error"),
    };
}

fn reduced_0<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Nonterminal::Nt0(..) => p.goto(nt, state_1, reduced_1),
        Nonterminal::Nt1(..) => p.goto(nt, state_2, reduced_2),
        Nonterminal::Nt2(..) => p.goto(nt, state_4, reduced_4),
        Nonterminal::Nt3(..) => p.goto(nt, state_5, reduced_5),
        _ => unreachable!(),
    };
}

fn state_1<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.accept(),
        Some(Token::Ident(_)) => p.shift(state_7, reduced_7),
        Some(Token::Keyword(Keyword::Token)) => p.shift(state_6, reduced_6),
        Some(Token::Semicolon) => p.shift(state_9, reduced_9),
        _ => panic!("syntax error"),
    };
}

fn reduced_1<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Nonterminal::Nt1(..) => p.goto(nt, state_8, reduced_8),
        Nonterminal::Nt2(..) => p.goto(nt, state_4, reduced_4),
        Nonterminal::Nt3(..) => p.goto(nt, state_5, reduced_5),
        _ => unreachable!(),
    };
}

fn state_2<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: () = reduce_rule_1(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: () = reduce_rule_1(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: () = reduce_rule_1(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_2<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_3<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_3(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_3(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_3(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_3<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_4<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let reduced: () = reduce_rule_4(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let reduced: () = reduce_rule_4(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let reduced: () = reduce_rule_4(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_4<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_5<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let reduced: () = reduce_rule_5(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let reduced: () = reduce_rule_5(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let reduced: () = reduce_rule_5(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_5<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_6<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Ident(_)) => p.shift(state_10, reduced_10),
        _ => panic!("syntax error"),
    };
}

fn reduced_6<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_7<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Colon) => p.shift(state_11, reduced_11),
        _ => panic!("syntax error"),
    };
}

fn reduced_7<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_8<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: () = reduce_rule_0(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: () = reduce_rule_0(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: () = reduce_rule_0(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_8<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_9<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_2(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_2(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_2(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_9<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_10<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Semicolon) => p.shift(state_12, reduced_12),
        _ => panic!("syntax error"),
    };
}

fn reduced_10<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_11<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Ident(_)) => p.shift(state_14, reduced_14),
        _ => panic!("syntax error"),
    };
}

fn reduced_11<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Nonterminal::Nt4(..) => p.goto(nt, state_13, reduced_13),
        _ => unreachable!(),
    };
}

fn state_12<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_6(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_6(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_6(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt2(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_12<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_13<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Semicolon) => p.shift(state_15, reduced_15),
        Some(Token::Pipe) => p.shift(state_16, reduced_16),
        _ => panic!("syntax error"),
    };
}

fn reduced_13<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_14<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_9(
                arg0,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Pipe) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_9(
                arg0,
            );
            Nonterminal::Nt4(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_14<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_15<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        None => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_7(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt3(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_7(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt3(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_7(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt3(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_15<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_16<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Ident(_)) => p.shift(state_17, reduced_17),
        _ => panic!("syntax error"),
    };
}

fn reduced_16<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_17<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Some(Token::Semicolon) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_8(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Pipe) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: () = reduce_rule_8(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt4(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_17<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}
