// Code automatically generated by perplex.

/// All nonterminals that may be pushed onto the stack.
enum Nonterminal {
    Nt0(ast::Desc),
    Nt1(ast::Item),
    Nt2(ast::TokenDecl),
    Nt3(ast::TokenName),
    Nt4(ast::RuleDecl),
    Nt5(Vec<ast::Variant>),
    Nt6(ast::Variant),
    Nt7(Vec<ast::Symbol>),
    Nt8(Vec<ast::Symbol>),
    Nt9(ast::Symbol),
    Nt10(ast::Symbol),
    Nt11(ast::RepSequence),
    Nt12(ast::Symbol),
}

impl Nonterminal {
    #[inline(always)]
    fn unwrap_nt0(self) -> ast::Desc {
        match self {
            Nonterminal::Nt0(nt) => nt,
            _ => panic!("expected nonterminal `ast::Desc`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt1(self) -> ast::Item {
        match self {
            Nonterminal::Nt1(nt) => nt,
            _ => panic!("expected nonterminal `ast::Item`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt2(self) -> ast::TokenDecl {
        match self {
            Nonterminal::Nt2(nt) => nt,
            _ => panic!("expected nonterminal `ast::TokenDecl`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt3(self) -> ast::TokenName {
        match self {
            Nonterminal::Nt3(nt) => nt,
            _ => panic!("expected nonterminal `ast::TokenName`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt4(self) -> ast::RuleDecl {
        match self {
            Nonterminal::Nt4(nt) => nt,
            _ => panic!("expected nonterminal `ast::RuleDecl`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt5(self) -> Vec<ast::Variant> {
        match self {
            Nonterminal::Nt5(nt) => nt,
            _ => panic!("expected nonterminal `Vec<ast::Variant>`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt6(self) -> ast::Variant {
        match self {
            Nonterminal::Nt6(nt) => nt,
            _ => panic!("expected nonterminal `ast::Variant`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt7(self) -> Vec<ast::Symbol> {
        match self {
            Nonterminal::Nt7(nt) => nt,
            _ => panic!("expected nonterminal `Vec<ast::Symbol>`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt8(self) -> Vec<ast::Symbol> {
        match self {
            Nonterminal::Nt8(nt) => nt,
            _ => panic!("expected nonterminal `Vec<ast::Symbol>`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt9(self) -> ast::Symbol {
        match self {
            Nonterminal::Nt9(nt) => nt,
            _ => panic!("expected nonterminal `ast::Symbol`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt10(self) -> ast::Symbol {
        match self {
            Nonterminal::Nt10(nt) => nt,
            _ => panic!("expected nonterminal `ast::Symbol`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt11(self) -> ast::RepSequence {
        match self {
            Nonterminal::Nt11(nt) => nt,
            _ => panic!("expected nonterminal `ast::RepSequence`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt12(self) -> ast::Symbol {
        match self {
            Nonterminal::Nt12(nt) => nt,
            _ => panic!("expected nonterminal `ast::Symbol`"),
        }
    }
}

impl ::std::fmt::Debug for Nonterminal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            Nonterminal::Nt0(..) => write!(f, "desc"),
            Nonterminal::Nt1(..) => write!(f, "item"),
            Nonterminal::Nt2(..) => write!(f, "token_decl"),
            Nonterminal::Nt3(..) => write!(f, "token_name"),
            Nonterminal::Nt4(..) => write!(f, "rule_decl"),
            Nonterminal::Nt5(..) => write!(f, "rule_list"),
            Nonterminal::Nt6(..) => write!(f, "variant"),
            Nonterminal::Nt7(..) => write!(f, "sequence_or_epsilon"),
            Nonterminal::Nt8(..) => write!(f, "sequence"),
            Nonterminal::Nt9(..) => write!(f, "symbol"),
            Nonterminal::Nt10(..) => write!(f, "core_symbol"),
            Nonterminal::Nt11(..) => write!(f, "repetition_sequence"),
            Nonterminal::Nt12(..) => write!(f, "primary_symbol"),
        }
    }
}

fn state_0<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_7, reduced_7),
        Some(Token::Keyword(Keyword::Token)) => p.shift(state_6, reduced_6),
        Some(Token::Semicolon) => p.shift(state_3, reduced_3),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_0<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt0(..) => p.goto(nt, state_1, reduced_1),
        Nonterminal::Nt1(..) => p.goto(nt, state_2, reduced_2),
        Nonterminal::Nt2(..) => p.goto(nt, state_4, reduced_4),
        Nonterminal::Nt4(..) => p.goto(nt, state_5, reduced_5),
        _ => unreachable!(),
    };
}

fn state_1<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.accept(),
        Some(Token::Ident(_)) => p.shift(state_7, reduced_7),
        Some(Token::Keyword(Keyword::Token)) => p.shift(state_6, reduced_6),
        Some(Token::Semicolon) => p.shift(state_9, reduced_9),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_1<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt1(..) => p.goto(nt, state_8, reduced_8),
        Nonterminal::Nt2(..) => p.goto(nt, state_4, reduced_4),
        Nonterminal::Nt4(..) => p.goto(nt, state_5, reduced_5),
        _ => unreachable!(),
    };
}

fn state_2<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: ast::Desc = reduce_desc_b(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: ast::Desc = reduce_desc_b(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: ast::Desc = reduce_desc_b(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: ast::Desc = reduce_desc_b(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_2<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_3<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Desc = reduce_desc_d(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Desc = reduce_desc_d(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Desc = reduce_desc_d(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Desc = reduce_desc_d(
                arg0,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_3<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_4<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let reduced: ast::Item = reduce_item_a(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let reduced: ast::Item = reduce_item_a(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let reduced: ast::Item = reduce_item_a(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let reduced: ast::Item = reduce_item_a(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_4<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_5<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let reduced: ast::Item = reduce_item_b(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let reduced: ast::Item = reduce_item_b(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let reduced: ast::Item = reduce_item_b(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt4();
            let reduced: ast::Item = reduce_item_b(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_5<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_6<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_11, reduced_11),
        Some(Token::Keyword(Keyword::End)) => p.shift(state_12, reduced_12),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_6<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt3(..) => p.goto(nt, state_10, reduced_10),
        _ => unreachable!(),
    };
}

fn state_7<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::LBrace) => p.shift(state_14, reduced_14),
        Some(Token::RArrow) => p.shift(state_13, reduced_13),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_7<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_8<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: ast::Desc = reduce_desc_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: ast::Desc = reduce_desc_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: ast::Desc = reduce_desc_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let reduced: ast::Desc = reduce_desc_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_8<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_9<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Desc = reduce_desc_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Desc = reduce_desc_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Desc = reduce_desc_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt0();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Desc = reduce_desc_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_9<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_10<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Semicolon) => p.shift(state_16, reduced_16),
        Some(Token::RArrow) => p.shift(state_15, reduced_15),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_10<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_11<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenName = reduce_token_name_a(
                arg0,
            );
            Nonterminal::Nt3(reduced)
        }),
        Some(Token::RArrow) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenName = reduce_token_name_a(
                arg0,
            );
            Nonterminal::Nt3(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_11<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_12<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenName = reduce_token_name_b(
                arg0,
            );
            Nonterminal::Nt3(reduced)
        }),
        Some(Token::RArrow) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenName = reduce_token_name_b(
                arg0,
            );
            Nonterminal::Nt3(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_12<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_13<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_18, reduced_18),
        Some(Token::Code(_)) => p.shift(state_17, reduced_17),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_13<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_14<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::Keyword(Keyword::Epsilon)) => p.shift(state_23, reduced_23),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_14<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt5(..) => p.goto(nt, state_19, reduced_19),
        Nonterminal::Nt6(..) => p.goto(nt, state_20, reduced_20),
        Nonterminal::Nt7(..) => p.goto(nt, state_21, reduced_21),
        Nonterminal::Nt8(..) => p.goto(nt, state_22, reduced_22),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_15<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Code(_)) => p.shift(state_30, reduced_30),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_15<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_16<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_c(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_c(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_c(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_c(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt2(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_16<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_17<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::LBrace) => p.shift(state_32, reduced_32),
        Some(Token::Comma) => p.shift(state_31, reduced_31),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_17<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_18<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::LBrace) => p.shift(state_33, reduced_33),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_18<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_19<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::Keyword(Keyword::Epsilon)) => p.shift(state_23, reduced_23),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        Some(Token::RBrace) => p.shift(state_34, reduced_34),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_19<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt6(..) => p.goto(nt, state_35, reduced_35),
        Nonterminal::Nt7(..) => p.goto(nt, state_21, reduced_21),
        Nonterminal::Nt8(..) => p.goto(nt, state_22, reduced_22),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_20<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt6();
            let reduced: Vec<ast::Variant> = reduce_rule_list_b(
                arg0,
            );
            Nonterminal::Nt5(reduced)
        }),
        Some(Token::Keyword(Keyword::Epsilon)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt6();
            let reduced: Vec<ast::Variant> = reduce_rule_list_b(
                arg0,
            );
            Nonterminal::Nt5(reduced)
        }),
        Some(Token::LParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt6();
            let reduced: Vec<ast::Variant> = reduce_rule_list_b(
                arg0,
            );
            Nonterminal::Nt5(reduced)
        }),
        Some(Token::RBrace) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt6();
            let reduced: Vec<ast::Variant> = reduce_rule_list_b(
                arg0,
            );
            Nonterminal::Nt5(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_20<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_21<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Semicolon) => p.shift(state_37, reduced_37),
        Some(Token::RArrow) => p.shift(state_36, reduced_36),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_21<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_22<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let reduced: Vec<ast::Symbol> = reduce_sequence_or_epsilon_a(
                arg0,
            );
            Nonterminal::Nt7(reduced)
        }),
        Some(Token::RArrow) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let reduced: Vec<ast::Symbol> = reduce_sequence_or_epsilon_a(
                arg0,
            );
            Nonterminal::Nt7(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_22<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt9(..) => p.goto(nt, state_38, reduced_38),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_23<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: Vec<ast::Symbol> = reduce_sequence_or_epsilon_b(
                arg0,
            );
            Nonterminal::Nt7(reduced)
        }),
        Some(Token::RArrow) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: Vec<ast::Symbol> = reduce_sequence_or_epsilon_b(
                arg0,
            );
            Nonterminal::Nt7(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_23<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_24<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_b(
                arg0,
            );
            Nonterminal::Nt8(reduced)
        }),
        Some(Token::LParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_b(
                arg0,
            );
            Nonterminal::Nt8(reduced)
        }),
        Some(Token::RParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_b(
                arg0,
            );
            Nonterminal::Nt8(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_b(
                arg0,
            );
            Nonterminal::Nt8(reduced)
        }),
        Some(Token::RArrow) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_b(
                arg0,
            );
            Nonterminal::Nt8(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_24<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_25<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let reduced: ast::Symbol = reduce_symbol_a(
                arg0,
            );
            Nonterminal::Nt9(reduced)
        }),
        Some(Token::LParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let reduced: ast::Symbol = reduce_symbol_a(
                arg0,
            );
            Nonterminal::Nt9(reduced)
        }),
        Some(Token::RParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let reduced: ast::Symbol = reduce_symbol_a(
                arg0,
            );
            Nonterminal::Nt9(reduced)
        }),
        Some(Token::Colon) => p.shift(state_39, reduced_39),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let reduced: ast::Symbol = reduce_symbol_a(
                arg0,
            );
            Nonterminal::Nt9(reduced)
        }),
        Some(Token::RArrow) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let reduced: ast::Symbol = reduce_symbol_a(
                arg0,
            );
            Nonterminal::Nt9(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_25<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_26<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let reduced: ast::Symbol = reduce_core_symbol_a(
                arg0,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::LParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let reduced: ast::Symbol = reduce_core_symbol_a(
                arg0,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::RParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let reduced: ast::Symbol = reduce_core_symbol_a(
                arg0,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Colon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let reduced: ast::Symbol = reduce_core_symbol_a(
                arg0,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let reduced: ast::Symbol = reduce_core_symbol_a(
                arg0,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Question) => p.shift(state_40, reduced_40),
        Some(Token::Star) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let reduced: ast::RepSequence = reduce_repetition_sequence_a(
                arg0,
            );
            Nonterminal::Nt11(reduced)
        }),
        Some(Token::Plus) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let reduced: ast::RepSequence = reduce_repetition_sequence_a(
                arg0,
            );
            Nonterminal::Nt11(reduced)
        }),
        Some(Token::RArrow) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let reduced: ast::Symbol = reduce_core_symbol_a(
                arg0,
            );
            Nonterminal::Nt10(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_26<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_27<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Star) => p.shift(state_41, reduced_41),
        Some(Token::Plus) => p.shift(state_42, reduced_42),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_27<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_28<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::LParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::RParen) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Colon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Question) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Star) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Plus) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::RArrow) => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_a(
                arg0,
            );
            Nonterminal::Nt12(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_28<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_29<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_29<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt8(..) => p.goto(nt, state_43, reduced_43),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_30<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Comma) => p.shift(state_44, reduced_44),
        Some(Token::Semicolon) => p.shift(state_45, reduced_45),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_30<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_31<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_46, reduced_46),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_31<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_32<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::Keyword(Keyword::Epsilon)) => p.shift(state_23, reduced_23),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_32<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt5(..) => p.goto(nt, state_47, reduced_47),
        Nonterminal::Nt6(..) => p.goto(nt, state_20, reduced_20),
        Nonterminal::Nt7(..) => p.goto(nt, state_21, reduced_21),
        Nonterminal::Nt8(..) => p.goto(nt, state_22, reduced_22),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_33<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::Keyword(Keyword::Epsilon)) => p.shift(state_23, reduced_23),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_33<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt5(..) => p.goto(nt, state_48, reduced_48),
        Nonterminal::Nt6(..) => p.goto(nt, state_20, reduced_20),
        Nonterminal::Nt7(..) => p.goto(nt, state_21, reduced_21),
        Nonterminal::Nt8(..) => p.goto(nt, state_22, reduced_22),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_34<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_d(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_d(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_d(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_d(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt4(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_34<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_35<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt6();
            let reduced: Vec<ast::Variant> = reduce_rule_list_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt5(reduced)
        }),
        Some(Token::Keyword(Keyword::Epsilon)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt6();
            let reduced: Vec<ast::Variant> = reduce_rule_list_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt5(reduced)
        }),
        Some(Token::LParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt6();
            let reduced: Vec<ast::Variant> = reduce_rule_list_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt5(reduced)
        }),
        Some(Token::RBrace) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt6();
            let reduced: Vec<ast::Variant> = reduce_rule_list_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt5(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_35<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_36<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_50, reduced_50),
        Some(Token::Code(_)) => p.shift(state_49, reduced_49),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_36<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_37<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::Keyword(Keyword::Epsilon)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::LParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::RBrace) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt6(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_37<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_38<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt8(reduced)
        }),
        Some(Token::LParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt8(reduced)
        }),
        Some(Token::RParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt8(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt8(reduced)
        }),
        Some(Token::RArrow) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt9();
            let reduced: Vec<ast::Symbol> = reduce_sequence_a(
                arg0,
                arg1,
            );
            Nonterminal::Nt8(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_38<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_39<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_51, reduced_51),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_39<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_40<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_b(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::LParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_b(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::RParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_b(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Colon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_b(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_b(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::RArrow) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt12();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_b(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_40<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_41<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::LParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::RParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Colon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::RArrow) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_c(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_41<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_42<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::LParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::RParen) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Colon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        Some(Token::RArrow) => p.reduce(2, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt11();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_core_symbol_d(
                arg0,
                arg1,
            );
            Nonterminal::Nt10(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_42<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_43<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        Some(Token::RParen) => p.shift(state_52, reduced_52),
        Some(Token::Semicolon) => p.shift(state_53, reduced_53),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_43<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt9(..) => p.goto(nt, state_38, reduced_38),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_44<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Code(_)) => p.shift(state_54, reduced_54),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_44<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_45<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(5, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(5, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(5, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(5, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
            );
            Nonterminal::Nt2(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_45<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_46<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::LBrace) => p.shift(state_55, reduced_55),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_46<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_47<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::Keyword(Keyword::Epsilon)) => p.shift(state_23, reduced_23),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        Some(Token::RBrace) => p.shift(state_56, reduced_56),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_47<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt6(..) => p.goto(nt, state_35, reduced_35),
        Nonterminal::Nt7(..) => p.goto(nt, state_21, reduced_21),
        Nonterminal::Nt8(..) => p.goto(nt, state_22, reduced_22),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_48<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::Keyword(Keyword::Epsilon)) => p.shift(state_23, reduced_23),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        Some(Token::RBrace) => p.shift(state_57, reduced_57),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_48<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt6(..) => p.goto(nt, state_35, reduced_35),
        Nonterminal::Nt7(..) => p.goto(nt, state_21, reduced_21),
        Nonterminal::Nt8(..) => p.goto(nt, state_22, reduced_22),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_49<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Comma) => p.shift(state_58, reduced_58),
        Some(Token::Semicolon) => p.shift(state_59, reduced_59),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_49<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_50<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Semicolon) => p.shift(state_60, reduced_60),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_50<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_51<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt9(reduced)
        }),
        Some(Token::LParen) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt9(reduced)
        }),
        Some(Token::RParen) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt9(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt9(reduced)
        }),
        Some(Token::RArrow) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt10();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt9(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_51<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_52<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::LParen) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::RParen) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Colon) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Question) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Star) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::Plus) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        Some(Token::RArrow) => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Symbol = reduce_primary_symbol_b(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt12(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_52<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_53<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_53<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt8(..) => p.goto(nt, state_61, reduced_61),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_54<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Semicolon) => p.shift(state_62, reduced_62),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_54<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_55<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::Keyword(Keyword::Epsilon)) => p.shift(state_23, reduced_23),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_55<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt5(..) => p.goto(nt, state_63, reduced_63),
        Nonterminal::Nt6(..) => p.goto(nt, state_20, reduced_20),
        Nonterminal::Nt7(..) => p.goto(nt, state_21, reduced_21),
        Nonterminal::Nt8(..) => p.goto(nt, state_22, reduced_22),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_56<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_c(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_c(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_c(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_c(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt4(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_56<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_57<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt4(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_57<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_58<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_64, reduced_64),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_58<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_59<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_c(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::Keyword(Keyword::Epsilon)) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_c(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::LParen) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_c(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::RBrace) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_c(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt6(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_59<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_60<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_b(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::Keyword(Keyword::Epsilon)) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_b(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::LParen) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_b(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::RBrace) => p.reduce(4, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_b(
                arg0,
                arg1,
                arg2,
                arg3,
            );
            Nonterminal::Nt6(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_60<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_61<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        Some(Token::RParen) => p.shift(state_65, reduced_65),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_61<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt9(..) => p.goto(nt, state_38, reduced_38),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_62<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(7, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let arg6 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(7, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let arg6 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(7, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let arg6 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
            );
            Nonterminal::Nt2(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(7, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt3();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let arg6 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::TokenDecl = reduce_token_decl_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
            );
            Nonterminal::Nt2(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_62<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_63<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.shift(state_28, reduced_28),
        Some(Token::Keyword(Keyword::Epsilon)) => p.shift(state_23, reduced_23),
        Some(Token::LParen) => p.shift(state_29, reduced_29),
        Some(Token::RBrace) => p.shift(state_66, reduced_66),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_63<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        Nonterminal::Nt6(..) => p.goto(nt, state_35, reduced_35),
        Nonterminal::Nt7(..) => p.goto(nt, state_21, reduced_21),
        Nonterminal::Nt8(..) => p.goto(nt, state_22, reduced_22),
        Nonterminal::Nt9(..) => p.goto(nt, state_24, reduced_24),
        Nonterminal::Nt10(..) => p.goto(nt, state_25, reduced_25),
        Nonterminal::Nt11(..) => p.goto(nt, state_27, reduced_27),
        Nonterminal::Nt12(..) => p.goto(nt, state_26, reduced_26),
        _ => unreachable!(),
    };
}

fn state_64<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Semicolon) => p.shift(state_67, reduced_67),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_64<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_65<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Star) => p.reduce(5, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RepSequence = reduce_repetition_sequence_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
            );
            Nonterminal::Nt11(reduced)
        }),
        Some(Token::Plus) => p.reduce(5, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_nonterminal().unwrap_nt8();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RepSequence = reduce_repetition_sequence_b(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
            );
            Nonterminal::Nt11(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_65<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_66<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        None => p.reduce(8, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let arg6 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg7 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Ident(_)) => p.reduce(8, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let arg6 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg7 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Keyword(Keyword::Token)) => p.reduce(8, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let arg6 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg7 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
            );
            Nonterminal::Nt4(reduced)
        }),
        Some(Token::Semicolon) => p.reduce(8, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let arg6 = args.next().unwrap().unwrap_nonterminal().unwrap_nt5();
            let arg7 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::RuleDecl = reduce_rule_decl_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
                arg6,
                arg7,
            );
            Nonterminal::Nt4(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_66<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}

fn state_67<P>(p: &mut P) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match *p.peek() {
        Some(Token::Ident(_)) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::Keyword(Keyword::Epsilon)) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::LParen) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt6(reduced)
        }),
        Some(Token::RBrace) => p.reduce(6, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_nonterminal().unwrap_nt7();
            let arg1 = args.next().unwrap().unwrap_terminal();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let arg3 = args.next().unwrap().unwrap_terminal();
            let arg4 = args.next().unwrap().unwrap_terminal();
            let arg5 = args.next().unwrap().unwrap_terminal();
            let reduced: ast::Variant = reduce_variant_a(
                arg0,
                arg1,
                arg2,
                arg3,
                arg4,
                arg5,
            );
            Nonterminal::Nt6(reduced)
        }),
        _ => panic!("syntax error, unexpected {:?}", p.peek()),
    };
}

fn reduced_67<P>(p: &mut P, nt: Nonterminal) where P: Parser<Terminal = Terminal, Nonterminal = Nonterminal> {
    match nt {
        _ => unreachable!(),
    };
}
