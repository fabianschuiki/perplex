// Copyright (c) 2018 Fabian Schuiki

//! Parser code generation.

use std::io::{Result, Write};

use grammar::{Grammar, NonterminalId, Symbol, TerminalId};
use machine::{Action, StateId, StateMachine};

/// A code generation backend.
///
/// Holds all information necessary to generate the code for a parser.
pub struct Backend {}

impl Backend {
    /// Create a new backend.
    pub fn new() -> Backend {
        Backend {}
    }
}

/// Additional information about generated code.
///
/// This structure is used inside the code generation functions and is used to
/// keep track of function and type names that were used.
struct BackendCache {}

impl BackendCache {
    fn state_fn_name(&mut self, id: StateId) -> String {
        format!("state_{}", id)
    }

    fn reduced_fn_name(&mut self, id: StateId) -> String {
        format!("reduced_{}", id)
    }

    fn terminal_pattern(&mut self, terminal: TerminalId) -> String {
        format!("Terminal::Unknown{}", terminal.as_usize())
    }

    fn nonterminal_pattern(&mut self, nonterminal: NonterminalId) -> String {
        format!("Nonterminal::Unknown{}", nonterminal.as_usize())
    }
}

/// Generate the code for the parser.
pub fn generate_parser<W: Write>(
    into: &mut W,
    backend: &Backend,
    machine: &StateMachine,
    grammar: &Grammar,
) -> Result<()> {
    let mut cache = BackendCache {};
    write!(into, "// Code automatically generated by perplex.\n")?;

    for state in machine.states() {
        let mut ta: Vec<_> = state
            .actions()
            .filter_map(|(symbol, action)| match symbol {
                Symbol::Terminal(tid) => Some((tid, action)),
                _ => None,
            })
            .collect();

        let nta: Vec<_> = state
            .actions()
            .filter_map(|(symbol, action)| match symbol {
                Symbol::Nonterminal(ntid) => Some((ntid, action)),
                _ => None,
            })
            .collect();

        write!(
            into,
            "\nfn {}(p: &mut Parser) {{\n",
            cache.state_fn_name(state.id())
        )?;
        write!(into, "    let token = p.peek();\n")?;
        write!(into, "    match token {{\n")?;
        for (tid, action) in ta {
            match action {
                Action::Shift(target_state) => {
                    write!(
                        into,
                        "        {} => p.shift({}, {}),\n",
                        cache.terminal_pattern(tid),
                        cache.state_fn_name(target_state),
                        cache.reduced_fn_name(target_state)
                    )?;
                }
                Action::Reduce(rule_id) => {
                    write!(
                        into,
                        "        {} => p.reduce(),\n",
                        cache.terminal_pattern(tid)
                    )?;
                }
            }
        }
        write!(into, "        _ => panic!(\"syntax error\"),\n")?;
        write!(into, "    }};\n")?;
        write!(into, "}}\n")?;

        if !nta.is_empty() {
            write!(
                into,
                "\nfn {}(p: &mut Parser, nt: Nonterminal) {{\n",
                cache.reduced_fn_name(state.id())
            )?;
            write!(into, "    match nt {{\n")?;
            for (ntid, action) in nta {
                let state_id = match action {
                    Action::Shift(sid) => sid,
                    _ => panic!("nonterminal must always trigger a shift action"),
                };
                write!(
                    into,
                    "        {} => p.goto({}, {}),\n",
                    cache.nonterminal_pattern(ntid),
                    cache.state_fn_name(state_id),
                    cache.reduced_fn_name(state_id)
                )?;
            }
            write!(into, "        _ => unreachable!(),\n")?;
            write!(into, "    }};\n")?;
            write!(into, "}}\n")?;
        }
    }

    Ok(())
}
