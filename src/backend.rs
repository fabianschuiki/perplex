// Copyright (c) 2018 Fabian Schuiki

//! Parser code generation.

use std::io::{Result, Write};
use std::collections::HashMap;

use grammar::{self, Grammar, NonterminalId, Symbol, TerminalId};
use machine::{Action, StateId, StateMachine};

/// A code generation backend.
///
/// Holds all information necessary to generate the code for a parser.
pub struct Backend {
    term_pats: HashMap<TerminalId, String>,
    nonterm_pats: HashMap<NonterminalId, String>,
}

impl Backend {
    /// Create a new backend.
    pub fn new() -> Backend {
        Backend {
            term_pats: HashMap::new(),
            nonterm_pats: HashMap::new(),
        }
    }

    /// Add a match pattern for a terminal.
    pub fn add_terminal<S: Into<String>>(&mut self, terminal: TerminalId, pattern: S) {
        self.term_pats.insert(terminal, pattern.into());
    }

    /// Add a match pattern for a nonterminal.
    pub fn add_nonterminal<S: Into<String>>(&mut self, nonterminal: NonterminalId, pattern: S) {
        self.nonterm_pats.insert(nonterminal, pattern.into());
    }
}

/// Additional information about generated code.
///
/// This structure is used inside the code generation functions and is used to
/// keep track of function and type names that were used.
struct BackendCache<'be> {
    backend: &'be Backend,
}

impl<'be> BackendCache<'be> {
    fn state_fn_name(&mut self, id: StateId) -> String {
        format!("state_{}", id)
    }

    fn reduced_fn_name(&mut self, id: StateId) -> String {
        format!("reduced_{}", id)
    }

    fn terminal_pattern(&mut self, terminal: TerminalId) -> String {
        match self.backend.term_pats.get(&terminal) {
            Some(s) => s.clone(),
            None => panic!("no pattern defined for terminal {:?}", terminal),
        }
    }

    fn nonterminal_pattern(&mut self, nonterminal: NonterminalId) -> String {
        match self.backend.nonterm_pats.get(&nonterminal) {
            Some(s) => s.clone(),
            None => panic!("no pattern defined for nonterminal {:?}", nonterminal),
        }
    }
}

/// Generate the code for the parser.
pub fn generate_parser<W: Write>(
    into: &mut W,
    backend: &Backend,
    machine: &StateMachine,
    grammar: &Grammar,
) -> Result<()> {
    let mut cache = BackendCache { backend: backend };
    write!(into, "// Code automatically generated by perplex.\n")?;

    for state in machine.states() {
        let mut ta: Vec<_> = state
            .actions()
            .filter_map(|(symbol, action)| match symbol {
                Symbol::Terminal(tid) => Some((tid, action)),
                _ => None,
            })
            .collect();

        let nta: Vec<_> = state
            .actions()
            .filter_map(|(symbol, action)| match symbol {
                Symbol::Nonterminal(ntid) => Some((ntid, action)),
                _ => None,
            })
            .collect();

        write!(
            into,
            "\nfn {}<P: Parser>(p: &mut P) {{\n",
            cache.state_fn_name(state.id())
        )?;
        write!(into, "    let token = p.peek();\n")?;
        write!(into, "    match token {{\n")?;
        for (tid, action) in ta {
            match action {
                Action::Shift(target_state) => {
                    write!(
                        into,
                        "        {} => p.shift({}, {}),\n",
                        cache.terminal_pattern(tid),
                        cache.state_fn_name(target_state),
                        cache.reduced_fn_name(target_state)
                    )?;
                }
                Action::Reduce(rule_id) => {
                    if rule_id == grammar::ACCEPT {
                        write!(
                            into,
                            "        {} => p.accept(),\n",
                            cache.terminal_pattern(tid)
                        )?;
                    } else {
                        let rule = &grammar[rule_id];
                        let (name, num) = (rule.name(), rule.symbols().len());
                        write!(
                            into,
                            "        {} => p.reduce({}, {}),\n",
                            cache.terminal_pattern(tid),
                            cache.nonterminal_pattern(name),
                            num
                        )?;
                    }
                }
            }
        }
        write!(into, "        _ => panic!(\"syntax error\"),\n")?;
        write!(into, "    }};\n")?;
        write!(into, "}}\n")?;

        write!(
            into,
            "\nfn {}<P: Parser>(p: &mut P, nt: Nonterminal) {{\n",
            cache.reduced_fn_name(state.id())
        )?;
        write!(into, "    match nt {{\n")?;
        for (ntid, action) in nta {
            let state_id = match action {
                Action::Shift(sid) => sid,
                _ => panic!("nonterminal must always trigger a shift action"),
            };
            write!(
                into,
                "        {} => p.goto(nt, {}, {}),\n",
                cache.nonterminal_pattern(ntid),
                cache.state_fn_name(state_id),
                cache.reduced_fn_name(state_id)
            )?;
        }
        write!(into, "        _ => unreachable!(),\n")?;
        write!(into, "    }};\n")?;
        write!(into, "}}\n")?;
    }

    Ok(())
}
