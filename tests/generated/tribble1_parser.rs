// Code automatically generated by perplex.

fn state_0<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::A => p.shift(state_2, reduced_2),
        Token::B => p.shift(state_3, reduced_3),
        _ => panic!("syntax error"),
    };
}

fn reduced_0<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Ast::S => p.goto(nt, state_1, reduced_1),
        _ => unreachable!(),
    };
}

fn state_1<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.accept(),
        _ => panic!("syntax error"),
    };
}

fn reduced_1<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_2<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::C => p.shift(state_6, reduced_6),
        _ => panic!("syntax error"),
    };
}

fn reduced_2<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Ast::A => p.goto(nt, state_4, reduced_4),
        Ast::B => p.goto(nt, state_5, reduced_5),
        _ => unreachable!(),
    };
}

fn state_3<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::C => p.shift(state_9, reduced_9),
        _ => panic!("syntax error"),
    };
}

fn reduced_3<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Ast::A => p.goto(nt, state_7, reduced_7),
        Ast::B => p.goto(nt, state_8, reduced_8),
        _ => unreachable!(),
    };
}

fn state_4<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::D => p.shift(state_10, reduced_10),
        _ => panic!("syntax error"),
    };
}

fn reduced_4<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_5<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::E => p.shift(state_11, reduced_11),
        _ => panic!("syntax error"),
    };
}

fn reduced_5<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_6<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::D => p.reduce(Ast::A, 1),
        Token::E => p.reduce(Ast::B, 1),
        _ => panic!("syntax error"),
    };
}

fn reduced_6<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_7<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::E => p.shift(state_12, reduced_12),
        _ => panic!("syntax error"),
    };
}

fn reduced_7<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_8<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::D => p.shift(state_13, reduced_13),
        _ => panic!("syntax error"),
    };
}

fn reduced_8<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_9<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::D => p.reduce(Ast::B, 1),
        Token::E => p.reduce(Ast::A, 1),
        _ => panic!("syntax error"),
    };
}

fn reduced_9<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_10<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.reduce(Ast::S, 3),
        _ => panic!("syntax error"),
    };
}

fn reduced_10<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_11<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.reduce(Ast::S, 3),
        _ => panic!("syntax error"),
    };
}

fn reduced_11<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_12<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.reduce(Ast::S, 3),
        _ => panic!("syntax error"),
    };
}

fn reduced_12<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_13<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.reduce(Ast::S, 3),
        _ => panic!("syntax error"),
    };
}

fn reduced_13<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}
