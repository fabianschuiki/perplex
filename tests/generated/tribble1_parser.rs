// Code automatically generated by perplex.

/// All nonterminals that may be pushed onto the stack.
enum Nonterminal {
    Nt0(NodeS),
    Nt1(NodeA),
    Nt2(NodeB),
}

impl Nonterminal {
    #[inline(always)]
    fn unwrap_nt0(self) -> NodeS {
        match self {
            Nonterminal::Nt0(nt) => nt,
            _ => panic!("expected nonterminal `NodeS`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt1(self) -> NodeA {
        match self {
            Nonterminal::Nt1(nt) => nt,
            _ => panic!("expected nonterminal `NodeA`"),
        }
    }
    #[inline(always)]
    fn unwrap_nt2(self) -> NodeB {
        match self {
            Nonterminal::Nt2(nt) => nt,
            _ => panic!("expected nonterminal `NodeB`"),
        }
    }
}

impl std::fmt::Debug for Nonterminal {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match *self {
            Nonterminal::Nt0(..) => write!(f, "S"),
            Nonterminal::Nt1(..) => write!(f, "A"),
            Nonterminal::Nt2(..) => write!(f, "B"),
        }
    }
}

fn state_0<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::A => p.shift(state_2, reduced_2),
        Token::B => p.shift(state_3, reduced_3),
        _ => panic!("syntax error"),
    };
}

fn reduced_0<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Nonterminal::Nt0(..) => p.goto(nt, state_1, reduced_1),
        _ => unreachable!(),
    };
}

fn state_1<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.accept(),
        _ => panic!("syntax error"),
    };
}

fn reduced_1<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_2<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::C => p.shift(state_6, reduced_6),
        _ => panic!("syntax error"),
    };
}

fn reduced_2<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Nonterminal::Nt1(..) => p.goto(nt, state_4, reduced_4),
        Nonterminal::Nt2(..) => p.goto(nt, state_5, reduced_5),
        _ => unreachable!(),
    };
}

fn state_3<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::C => p.shift(state_9, reduced_9),
        _ => panic!("syntax error"),
    };
}

fn reduced_3<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        Nonterminal::Nt1(..) => p.goto(nt, state_7, reduced_7),
        Nonterminal::Nt2(..) => p.goto(nt, state_8, reduced_8),
        _ => unreachable!(),
    };
}

fn state_4<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::D => p.shift(state_10, reduced_10),
        _ => panic!("syntax error"),
    };
}

fn reduced_4<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_5<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::E => p.shift(state_11, reduced_11),
        _ => panic!("syntax error"),
    };
}

fn reduced_5<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_6<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::D => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: NodeA = reduce_rule_4(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        Token::E => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: NodeB = reduce_rule_5(
                arg0,
            );
            Nonterminal::Nt2(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_6<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_7<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::E => p.shift(state_12, reduced_12),
        _ => panic!("syntax error"),
    };
}

fn reduced_7<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_8<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::D => p.shift(state_13, reduced_13),
        _ => panic!("syntax error"),
    };
}

fn reduced_8<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_9<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::D => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: NodeB = reduce_rule_5(
                arg0,
            );
            Nonterminal::Nt2(reduced)
        }),
        Token::E => p.reduce(1, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let reduced: NodeA = reduce_rule_4(
                arg0,
            );
            Nonterminal::Nt1(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_9<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_10<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: NodeS = reduce_rule_0(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_10<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_11<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: NodeS = reduce_rule_1(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_11<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_12<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt1();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: NodeS = reduce_rule_2(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_12<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}

fn state_13<P: Parser>(p: &mut P) {
    let token = p.peek();
    match token {
        Token::Eof => p.reduce(3, |args|{
            let mut args = args.into_iter();
            let arg0 = args.next().unwrap().unwrap_terminal();
            let arg1 = args.next().unwrap().unwrap_nonterminal().unwrap_nt2();
            let arg2 = args.next().unwrap().unwrap_terminal();
            let reduced: NodeS = reduce_rule_3(
                arg0,
                arg1,
                arg2,
            );
            Nonterminal::Nt0(reduced)
        }),
        _ => panic!("syntax error"),
    };
}

fn reduced_13<P: Parser>(p: &mut P, nt: Nonterminal) {
    match nt {
        _ => unreachable!(),
    };
}
